<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Visualizador 3D - Colores Reales</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            overflow: hidden; 
            touch-action: none; 
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #status {
            position: fixed;
            top: 10px;
            left: 10px;
            color: lime;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            z-index: 100;
            font-size: 14px;
            border-radius: 5px;
        }
        .audio-meter {
            position: fixed;
            bottom: 70px;
            left: 10px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }
        .audio-meter-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            transition: width 0.1s;
        }
        .instructions {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            z-index: 100;
            font-size: 14px;
            border-radius: 5px;
        }
        .button-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.2s;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            outline: none;      /* Eliminar contorno al hacer focus */
            touch-action: manipulation; /* Optimizar para touch */
            -webkit-tap-highlight-color: transparent; /* Eliminar highlight en iOS */
        }
        .control-button:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }
        /* Estilos espec√≠ficos para m√≥viles y tablets */
        @media (max-width: 768px) {
            .control-button {
                font-size: 15px;
                padding: 14px 20px; /* Botones m√°s altos en m√≥viles */
                margin-bottom: 5px; /* M√°s separaci√≥n entre botones */
            }
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
        }
        #loading .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .preview {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 5px;
            overflow: hidden;
            z-index: 99;
            display: none;
        }
        .color-sample {
            position: fixed;
            bottom: 100px;
            right: 10px;
            width: 50px;
            height: 50px;
            border-radius: 5px;
            border: 2px solid white;
            z-index: 100;
        }
        @media (max-width: 768px) {
            .instructions { font-size: 12px; }
            .control-button { font-size: 14px; padding: 12px 16px; }
            .audio-meter { width: 150px; }
        }
        /* Animaci√≥n para feedback t√°ctil */
        @keyframes buttonPress {
            0% { transform: scale(1); }
            50% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }
        .button-pressed {
            animation: buttonPress 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <p>Cargando visualizador 3D...</p>
        <p id="loadingText">Iniciando...</p>
    </div>
    
    <div id="status">Inicializando...</div>
    
    <div class="audio-meter">
        <div class="audio-meter-fill" id="audioMeterFill"></div>
    </div>
    
    <div class="button-panel">
        <button class="control-button" id="photoButton">üì∏ Foto</button>
        <button class="control-button" id="recordButton">üî¥ Grabar</button>
        <button class="control-button" id="effectButton">üåà Efecto</button>
        <button class="control-button" id="cameraButton">üìπ Cambiar c√°mara</button>
        <button class="control-button" id="previewButton">üëÅÔ∏è Previsualizar</button>
    </div>
    
    <div class="preview" id="preview"></div>
    <div class="color-sample" id="colorSample"></div>
    
    <div class="instructions">
        <p>‚Ä¢ Desliza para rotar la vista</p>
        <p>‚Ä¢ Pellizca para zoom</p>
        <p>‚Ä¢ El medidor muestra el nivel de audio</p>
    </div>

    <!-- Scripts necesarios -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5.easycam@1.0.0/p5.easycam.min.js"></script>

    <script>
        // Variables globales
        let canvas;
        let video;
        let mic;
        let offset = 0;
        let recording = false;
        let statusElement;
        let loadingElement;
        let loadingTextElement;
        let audioMeterFill;
        let colorSample;
        let showPreview = false;
        let previewElement;
        let chunks = [];
        let recorder;
        let isMobile = false;
        let canRecord = false;
        let usingBackCamera = false;
        let easycam;
        let hasBeenTouched = false; // Para detectar interacci√≥n inicial
        
        // Variables para efectos 3D
        let depthFactor = 2.0;     // Factor de profundidad
        let sphereSize = 3;        // Tama√±o de las esferas
        let pointDensity = 5;      // Densidad de los puntos (menor = m√°s denso)
        let mobilePointDensity = 8; // Densidad para m√≥viles
        let effectIntensity = 1.0;  // Intensidad del efecto de audio
        
        // Variables de renderizado
        let audioLevel = 0;
        let sampledColor = [255, 255, 255];
        
        // Variables para manejo de eventos de c√°mara
        let canUseCameras = false;
        let canRenderScene = false;

        // Elementos del DOM - referencias globales
        let photoButton, recordButton, effectButton, previewButton, cameraButton;
        
        // Detectar vibraci√≥n
        const canVibrate = "vibrate" in navigator;
        
        // Funci√≥n para dar feedback t√°ctil
        function vibrateDevice(duration = 50) {
            if (canVibrate) {
                try {
                    navigator.vibrate(duration);
                } catch (e) {
                    console.log("Vibraci√≥n no soportada");
                }
            }
        }
        
        // Funci√≥n mejorada para animaci√≥n de botones
        function animateButton(button) {
            button.classList.add("button-pressed");
            setTimeout(() => {
                button.classList.remove("button-pressed");
            }, 300);
        }
        
        window.onload = function() {
            // Configurar referencias a elementos DOM
            statusElement = document.getElementById('status');
            loadingElement = document.getElementById('loading');
            loadingTextElement = document.getElementById('loadingText');
            audioMeterFill = document.getElementById('audioMeterFill');
            colorSample = document.getElementById('colorSample');
            previewElement = document.getElementById('preview');
            
            // Configurar botones
            photoButton = document.getElementById('photoButton');
            recordButton = document.getElementById('recordButton');
            effectButton = document.getElementById('effectButton');
            previewButton = document.getElementById('previewButton');
            cameraButton = document.getElementById('cameraButton');
            
            // Detectar tipo de dispositivo para optimizar configuraci√≥n
            detectDevice();
            
            // Detectar si el navegador soporta MediaRecorder
            canRecord = (typeof MediaRecorder !== 'undefined');
            if (!canRecord) {
                recordButton.style.display = 'none';
            }
            
            // Agregar manejadores optimizados para dispositivos t√°ctiles
            setupTouchControls();
            
            // Prevenir gestos del navegador en dispositivos t√°ctiles
            document.addEventListener('gesturestart', function(e) {
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', function(e) {
                if (e.target.closest('.control-button')) {
                    e.preventDefault(); // Prevenir scroll cuando tocas botones
                }
            }, { passive: false });
            
            updateLoadingText("Configuraci√≥n inicial completada");
        };
        
        // Configurar controladores t√°ctiles optimizados
        function setupTouchControls() {
            // Funci√≥n para manejar todos los eventos t√°ctiles en botones
            function setupButtonEvents(button, action) {
                ['touchstart', 'mousedown'].forEach(eventType => {
                    button.addEventListener(eventType, function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        vibrateDevice();
                        animateButton(this);
                        
                        // En dispositivos iOS, es mejor disparar la acci√≥n en touchstart
                        if (isMobile && eventType === 'touchstart') {
                            action();
                        }
                        // En desktop, esperar al click real
                        if (!isMobile && eventType === 'mousedown') {
                            action();
                        }
                        
                        return false;
                    }, { passive: false });
                });
                
                // Para asegurar compatibilidad con todos los dispositivos
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    // Solo ejecutar en dispositivos que no sean m√≥viles o si no se ha manejado ya
                    if (!hasBeenTouched) {
                        action();
                    }
                    hasBeenTouched = false;
                    return false;
                }, { passive: false });
            }
            
            // Configurar cada bot√≥n con su acci√≥n correspondiente
            setupButtonEvents(photoButton, takePhoto);
            setupButtonEvents(recordButton, toggleRecording);
            setupButtonEvents(effectButton, cycleEffect);
            setupButtonEvents(previewButton, togglePreview);
            setupButtonEvents(cameraButton, toggleCamera);
        }

        function detectDevice() {
            // Detectar dispositivo: m√≥vil, tablet o desktop
            const userAgent = navigator.userAgent.toLowerCase();
            const isMobileDevice = /android|webos|iphone|ipod|blackberry|iemobile|opera mini/.test(userAgent);
            const isTablet = /ipad|android/.test(userAgent) && !/mobile/.test(userAgent);
            
            isMobile = isMobileDevice || isTablet;
            
            if (isMobileDevice) {
                pointDensity = mobilePointDensity;
                sphereSize = 2.5;  // Esferas m√°s peque√±as en m√≥viles para rendimiento
            } else if (isTablet) {
                pointDensity = 6;
                sphereSize = 3;
            }
            
            updateLoadingText("Detectado: " + (isMobileDevice ? "Dispositivo m√≥vil" : isTablet ? "Tablet" : "Escritorio"));
        }

        function updateLoadingText(text) {
            if (loadingTextElement) {
                loadingTextElement.textContent = text;
            }
        }
        
        function hideLoading() {
            loadingElement.style.display = 'none';
        }

        function setup() {
            updateLoadingText("Creando lienzo...");
            canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            
            // Inicializar EasyCam con par√°metros adaptados para mobiles y t√°ctiles
            easycam = createEasyCam();
            easycam.setDistanceMin(30);
            easycam.setDistanceMax(3000);
            
            // Ajustes especiales de EasyCam para dispositivos t√°ctiles
            if (isMobile) {
                easycam.setRotationConstraint(true, true, true); // Restringir rotaci√≥n para mejor control
                easycam.setPanConstraint(true, true, true); // Restringir panning
                easycam.setDampingScale(0.7); // Menos inercia para mejor control
            }
            
            updateLoadingText("Solicitando acceso a la c√°mara...");
            startCapture(usingBackCamera);
            
            // Crear un peque√±o elemento de vista previa
            previewElement.style.width = "160px";
            previewElement.style.height = "120px";
            
            // Iniciar audio
            updateLoadingText("Configurando audio...");
            userStartAudio().then(() => {
                mic = new p5.AudioIn();
                mic.start();
                updateLoadingText("Audio iniciado");
                setTimeout(hideLoading, 1000);
            }).catch(e => {
                updateStatus("‚ö†Ô∏è Sin acceso a micr√≥fono");
                setTimeout(hideLoading, 1000);
            });
            
            // Configurar grabaci√≥n
            if (canRecord) {
                setupRecorder();
            }
            
            frameRate(isMobile ? 30 : 60);
            pixelDensity(1);
            
            updateLoadingText("¬°Todo listo!");
        }

        function startCapture(backCamera) {
            let constraints = {
                video: {
                    facingMode: (backCamera ? 'environment' : 'user'),
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                }
            };
            
            if (video) {
                video.remove();
            }
            
            video = createCapture(constraints, function(stream) {
                if (stream.active) {
                    console.log("Captura de video iniciada.");
                    canRenderScene = true;
                    canUseCameras = true;
                    
                    // Crear un video preview peque√±o
                    if (previewElement.firstChild) {
                        previewElement.removeChild(previewElement.firstChild);
                    }
                    let preview = document.createElement('video');
                    preview.srcObject = stream;
                    preview.autoplay = true;
                    preview.muted = true;
                    preview.style.width = "100%";
                    preview.style.height = "100%";
                    preview.style.objectFit = "cover";
                    preview.style.borderRadius = "5px";
                    previewElement.appendChild(preview);
                } else {
                    console.log("No se encontraron dispositivos de captura.");
                    canRenderScene = false;
                    updateStatus("‚ö†Ô∏è Error al acceder a la c√°mara");
                }
            });
            video.hide();
        }

        function toggleCamera() {
            if (!canUseCameras) {
                updateStatus("‚ö†Ô∏è No se detectaron c√°maras disponibles");
                return;
            }
            
            usingBackCamera = !usingBackCamera;
            updateStatus(usingBackCamera ? "üìπ Usando c√°mara trasera" : "üìπ Usando c√°mara frontal");
            startCapture(usingBackCamera);
            
            // Feedback visual y t√°ctil
            vibrateDevice(100); // Vibraci√≥n m√°s larga para cambio de c√°mara
        }

        function setupRecorder() {
            try {
                const stream = document.querySelector('canvas').captureStream(30);
                recorder = new MediaRecorder(stream, {mimeType: 'video/webm;codecs=vp9'});
                
                recorder.ondataavailable = e => {
                    if (e.data.size) {
                        chunks.push(e.data);
                    }
                };
                
                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    chunks = [];
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    document.body.appendChild(a);
                    a.style = 'display: none';
                    a.href = url;
                    a.download = 'visual3d-' + Date.now() + '.webm';
                    a.click();
                    window.URL.revokeObjectURL(url);
                    updateStatus("‚úÖ Grabaci√≥n guardada");
                };
            } catch (e) {
                console.error("Error al configurar grabaci√≥n:", e);
                recordButton.style.display = 'none';
                canRecord = false;
            }
        }

        function updateStatus(message) {
            statusElement.innerHTML = message;
        }

        function takePhoto() {
            saveCanvas('visual3d-' + Date.now(), 'png');
            updateStatus('üì∏ Imagen guardada');
            
            // Feedback t√°ctil
            vibrateDevice();
            
            // Efecto visual de flash
            let flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = 'white';
            flash.style.opacity = '0.7';
            flash.style.zIndex = '9999';
            flash.style.pointerEvents = 'none';
            flash.style.transition = 'opacity 0.5s';
            document.body.appendChild(flash);
            
            setTimeout(() => {
                flash.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(flash);
                }, 500);
            }, 100);
        }
        
        function toggleRecording() {
            if (!canRecord) return;
            
            recording = !recording;
            if (recording) {
                chunks = [];
                recorder.start();
                updateStatus('üî¥ Grabando...');
                recordButton.textContent = "‚èπÔ∏è Detener";
                recordButton.style.backgroundColor = "rgba(255,0,0,0.4)";
                vibrateDevice(100); // Vibraci√≥n m√°s larga al iniciar grabaci√≥n
            } else {
                recorder.stop();
                updateStatus('‚è≥ Procesando grabaci√≥n...');
                recordButton.textContent = "üî¥ Grabar";
                recordButton.style.backgroundColor = "rgba(255,255,255,0.2)";
                vibrateDevice([50, 50, 150]); // Patr√≥n de vibraci√≥n al detener
            }
        }
        
        function cycleEffect() {
            if (depthFactor === 2.0) {
                depthFactor = 3.0;
                effectIntensity = 1.5;
                updateStatus("üåä Efecto: Ondas intensas");
            } else if (depthFactor === 3.0) {
                depthFactor = 4.0;
                effectIntensity = 2.0;
                updateStatus("üèîÔ∏è Efecto: Monta√±as");
            } else {
                depthFactor = 2.0;
                effectIntensity = 1.0;
                updateStatus("üåà Efecto: Normal");
            }
            vibrateDevice();
        }
        
        function togglePreview() {
            showPreview = !showPreview;
            previewElement.style.display = showPreview ? 'block' : 'none';
            updateStatus(showPreview ? "üëÅÔ∏è Previsualizaci√≥n activada" : "üëÅÔ∏è Previsualizaci√≥n desactivada");
            vibrateDevice();
        }

        function draw() {
            background(0);
            
            // Obtener el nivel de audio y actualizar medidor
            if (mic) {
                audioLevel = mic.getLevel();
                let decibelPercentage = min(audioLevel * 500, 100);
                audioMeterFill.style.width = decibelPercentage + "%";
            }
            
            // Dibujar s√≥lo si el video est√° listo y podemos renderizar
            if (video && video.loadedmetadata && video.width > 0 && canRenderScene) {                
                // Obtener el nivel de audio para efectos visuales
                let volume = audioLevel * 2000 * effectIntensity;
                offset += 0.05;
                
                // Cargar pixels de video para acceder a los colores reales
                video.loadPixels();
                
                // Ajustar el origen al centro
                translate(-width / 2, -height / 2, 0);
                
                // Centro del video
                let centerX = video.width / 2;
                let centerY = video.height / 2;
                
                // Renderizar la escena con esferas
                for (let y = 0; y < video.height; y += pointDensity) {
                    for (let x = 0; x < video.width; x += pointDensity) {
                        // Obtener los colores de p√≠xeles directamente del video
                        let index = (x + y * video.width) * 4;
                        let r = video.pixels[index];
                        let g = video.pixels[index + 1];
                        let b = video.pixels[index + 2];
                        
                        // Solo dibujar si el pixel tiene suficiente informaci√≥n de color
                        if (r + g + b > 20) {
                            // Calcular brillo y profundidad Z
                            let bright = (r + g + b) / 3;
                            let z = map(bright, 0, 255, -150 * depthFactor, 150);
                            
                            // Aplicar efecto de onda basado en el audio
                            let d = dist(x, y, centerX, centerY);
                            z += sin(d/10 + offset) * volume * 0.5;
                            
                            // Muestrear un color central para mostrarlo en la muestra
                            if (abs(x - centerX) < 10 && abs(y - centerY) < 10) {
                                sampledColor = [r, g, b];
                                colorSample.style.backgroundColor = `rgb(${r},${g},${b})`;
                            }
                            
                            // Dibujar esfera con el color exacto del p√≠xel
                            push();
                            translate(x, y, z - 100);  // Ajuste para profundidad base
                            fill(r, g, b);
                            noStroke();
                            sphere(sphereSize);
                            pop();
                        }
                    }
                }
                
                // Actualizar mensaje con nivel de decibelios
                if (frameCount % 30 === 0 && !recording) {
                    updateStatus(`FPS: ${nf(frameRate(), 2, 0)} | Decibelios: ${nf(audioLevel*100, 2, 1)}`);
                }
            }
        }

        // Manejo de eventos t√°ctiles para canvas de p5
        function touchStarted() {
            // Marcar que ha habido interacci√≥n t√°ctil
            hasBeenTouched = true;
            
            // Verificar si el toque fue en un bot√≥n (para evitar conflictos)
            for (let i = 0; i < touches.length; i++) {
                let touch = touches[i];
                let element = document.elementFromPoint(touch.x, touch.y);
                if (element && element.classList.contains('control-button')) {
                    return false; // No hacer nada si tocamos un bot√≥n
                }
            }
            
            // Detectar gesto de dos dedos para tomar foto
            if (touches.length === 2) {
                let d = dist(touches[0].x, touches[0].y, touches[1].x, touches[1].y);
                if (d < 100) { // Si los dedos est√°n cerca, toma una foto
                    takePhoto();
                    return false;
                }
            }
            
            return false; // Prevenir comportamiento por defecto
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            if (video) {
                video.size(windowWidth, windowHeight);
            }
        }
    </script>
</body>
</html>
